#include <map>

#include "RVizVisualization.h"

#include <sstream>

#define ID_PTU_FOV 0 //XXX vis
#define ID_TESSELLATED_SPHERE 1
#define ID_SAMPLES 2
#define ID_SAMPLES_3D 3
#define ID_QUADS 20000

#define TARGET_FRAME "/PTU"

//File scoped.
static int maxID = ID_QUADS;

//Global variable defined in asr state machine
extern std::stringstream absPathDir;

namespace ASR {
	
  RVizVisualization::RVizVisualization(QuadGridPtr pGrid) : grid(pGrid) {
		
    ros::NodeHandle n("~");
		
    n.getParam("quad_pan_deg", quad_pan_deg);
    n.getParam("quad_tilt_deg", quad_tilt_deg);

    if(!n.getParam("enableEvaluation", enableEvaluation))
      enableEvaluation = false;
		
    //Init publishers for every part of the visualization.
    ismPublisher = n.advertise<visualization_msgs::Marker>("ism_marker", 10);
    arrowPublisher = n.advertise<visualization_msgs::Marker>("arrow_marker", 10);
    tsPublisher = n.advertise<visualization_msgs::Marker>("tessellated_sphere_marker", 10);
    qgPublisher = n.advertise<visualization_msgs::MarkerArray>("quadgrid_markers", 10);
    fovPublisher = n.advertise<visualization_msgs::Marker>("ptu_fov_marker", 10);
    samples2dPublisher = n.advertise<visualization_msgs::Marker>("samples2d_markers", 10);
    samples3dPublisher = n.advertise<visualization_msgs::Marker>("samples3d_markers", 10);
    hypothesesPublisher = n.advertise<visualization_msgs::MarkerArray>("unfound_objects", 10);
  }
	
  RVizVisualization::~RVizVisualization() {}	
	
  void RVizVisualization::drawTS(float panMin, float panMax, float tiltMin, float tiltMax) {
    float r = TS_RADIUS;
		
    ROS_INFO("Size of quad in deg (pan, tilt): (%.2f, %.2f).\n", quad_pan_deg, quad_tilt_deg);
    float panStep = quad_pan_deg;
    float tiltStep = quad_tilt_deg;
    visualization_msgs::Marker lineList;
    lineList.header.frame_id = TARGET_FRAME;
    lineList.header.stamp = ros::Time::now();
    lineList.ns = "tessellated_sphere";
    lineList.action = visualization_msgs::Marker::ADD;
    lineList.type = visualization_msgs::Marker::LINE_LIST;
    lineList.id = ID_TESSELLATED_SPHERE;
		
    lineList.scale.x = GRID_SCALE;
    lineList.color.r = 0.6;
    lineList.color.g = 0.6;
    lineList.color.b = 0.6;
    lineList.color.a = 1.0;
    geometry_msgs::Point last;
    geometry_msgs::Point current;
		
    //horizontal lines
    for (float t = tiltMin; t <= tiltMax; t += tiltStep) {
      last = angleToPTU(panMin, t, r);
      for (float p = panMin + panStep; p <= panMax; p += panStep) {
	current = angleToPTU(p, t, r);
	lineList.points.push_back(last);
	lineList.points.push_back(current);
	last = current;
      }
    }
		
    //vertical lines
    for (float p = panMin; p <= panMax; p += panStep) {
      last = angleToPTU(p, tiltMin, r);
      for (float t = tiltMin + tiltStep; t <= tiltMax; t += tiltStep) {
	current = angleToPTU(p, t, r);
	lineList.points.push_back(last);
	lineList.points.push_back(current);
	last = current;
      }
    }
		
    tsPublisher.publish(lineList);
  }
	
  void RVizVisualization::drawFoV(float pan, float tilt, float foVX, float foVY) {
    float r = TS_RADIUS * 0.85;
    visualization_msgs::Marker m;
    m.header.frame_id = TARGET_FRAME;
    m.header.stamp = ros::Time::now();
    m.ns = "ptu_field_of_view";
    m.action = visualization_msgs::Marker::ADD;
    m.type = visualization_msgs::Marker::CUBE;
    m.id = ID_PTU_FOV;
		
    m.color.r = 1;
    //	m.color.g = 1;
    m.color.b = 1;
    m.color.a = 0.5;
		
    m.pose.position = angleToPTU(pan, tilt, r);
    tf::Quaternion q = angleToQuat(pan, tilt);
    m.pose.orientation.x = q.x();
    m.pose.orientation.y = q.y();
    m.pose.orientation.z = q.z();
    m.pose.orientation.w = q.w();
		
    Eigen::Vector2f extent = getQuadExtent(Eigen::Vector2f(pan, tilt), r, foVX, foVY);
		
    m.scale.x = extent.x() - GRID_SCALE;
    m.scale.y = extent.y() - GRID_SCALE;
    m.scale.z = GRID_SCALE;
		
    fovPublisher.publish(m);
  }
	
  geometry_msgs::Point RVizVisualization::angleToPTU(float pan, float tilt, float r) {
    geometry_msgs::Point point;
    pan *= -DEG_TO_RAD;
    tilt *= DEG_TO_RAD;
    point.x = r * sin(pan) * cos(tilt);
    point.y = - r * cos(pan) * cos(tilt);
    point.z = - r * sin(tilt);
    //	ROS_INFO("%f %f", pan, tilt);
    return point;
  }
	
  tf::Quaternion RVizVisualization::angleToQuat(float pan, float tilt) {
    return tf::createQuaternionFromRPY((tilt + 90) * DEG_TO_RAD, 0, (-pan) * DEG_TO_RAD);
  }
	
  Eigen::Vector2f RVizVisualization::getQuadExtent(Eigen::Vector2f pos, float r, float panSize, float tiltSize) {
    geometry_msgs::Point px1 = angleToPTU(pos.x() - panSize / 2.0, pos.y(), r);
    geometry_msgs::Point px2 = angleToPTU(pos.x() + panSize / 2.0, pos.y(), r);
    geometry_msgs::Point py1 = angleToPTU(pos.x(), pos.y() - tiltSize / 2.0, r);
    geometry_msgs::Point py2 = angleToPTU(pos.x(), pos.y() + tiltSize / 2.0, r);
		
    Eigen::Vector3f cvpx1(px1.x, px1.y, px1.z);
    Eigen::Vector3f cvpx2(px2.x, px2.y, px2.z);
    Eigen::Vector3f cvpy1(py1.x, py1.y, py1.z);
    Eigen::Vector3f cvpy2(py2.x, py2.y, py2.z);
		
    Eigen::Vector2f p;
    p.x() = (cvpx1 - cvpx2).norm();
    p.y() = (cvpy1 - cvpy2).norm();
		
    return p;
  }
	
  void RVizVisualization::drawRecognitionResult(ISM::RecognitionResultPtr result, int level, double step, ISM::PointPtr parentPoint, std::string prefix, unsigned char action) {
    auto refPoint = this->applyLevelToPoint(result->getReferencePosePtr()->getPointPtr(), level, step);
    auto refMarker = pointToSphere(refPoint, action);
    refMarker.id = 0;
    refMarker.ns = prefix + "scene_recognition_" + result->getPatternName() + "_ref";
    refMarker.color.g = 1.0;
    refMarker.color.a = 0.5;
    ismPublisher.publish(refMarker);
    
    int id = 1;
    std_msgs::ColorRGBA color = confidenceToColor(result->getConfidence());
    for (auto& obj : result->getRecognizedObjectsPtr()->getObjects()) {
      //auto m = lineBetweenPoints(refPoint, this->applyLevelToPoint(obj->getPosePtr()->getPointPtr(), level, step), action);
      auto m = arrowBetweenPoints2(refPoint, this->applyLevelToPoint(obj->getPosePtr()->getPointPtr(), level, step));
      m.ns = prefix + "scene_recognition_" + result->getPatternName() + "_lines";
      m.id = id++;
      m.color = color;
      m.color.a = 1.0;
      ismPublisher.publish(m);
    }
		
    if (parentPoint) {
      id = 1;
      //auto m = arrowBetweenPoints(refPoint, parentPoint, action);
      auto m = arrowBetweenPoints2(refPoint, parentPoint);
      m.ns = prefix + "scene_recognition_" + result->getPatternName() + "_parent_arrows";
      m.id = id++;
      m.color.r = 1.0;
      m.color.a = 1.0;
      ismPublisher.publish(m);
    }
		
    for (auto& subPattern : result->getSubPatterns()) {
      this->drawRecognitionResult(subPattern, level + 1, step,
				  this->applyLevelToPoint(subPattern->getReferencePosePtr()->getPointPtr(), level, step), prefix, action);
    }
  }
	
  ISM::PointPtr RVizVisualization::applyLevelToPoint(ISM::PointPtr p, int level, double step) {
    Visualizer::CoordinateVectorPtr pptr = Visualizer::applyLevelToPoint(p, level, step);
    return(ISM::PointPtr(new ISM::Point(pptr->getX(), pptr->getY(), pptr->getZ())));
  }
	
	
  visualization_msgs::Marker RVizVisualization::pointToSphere(ISM::PointPtr point, unsigned char action) {
    return (Visualizer::pointToSphere(point, 0.02, 0.02, 0.02, TARGET_FRAME, 1.0f, &action));
  }
    /*
  visualization_msgs::Marker RVizVisualization::lineBetweenPoints(ISM::PointPtr point1, ISM::PointPtr point2,
                                  unsigned char action) {
    std::vector<Visualizer::CoordinateVectorPtr> points {point1, point2};
    return (Visualizer::lineBetweenPoints(points, 0.008, 0.008, 0.008, TARGET_FRAME, 1.0f, &action));
  }*/
	
  void RVizVisualization::drawQuads(float panMin, float panMax, float tiltMin, float tiltMax) {
    float r = TS_RADIUS * 0.99;
    visualization_msgs::MarkerArray cubes;
		
    int maxCount = 1;
    //find max for coloring
		
    for (std::vector<Quad> qVector : grid->grid) {
      for (Quad q : qVector) {
	int c = q.getObjectPresenceCounters();
	if (maxCount < c) {
	  maxCount = c;
	}
      }
    }
		
    //draw quads
    int id = ID_QUADS;
		
    for (uint i = 0; i < grid->grid.size(); i++) {
      for (uint j = 0; j < grid->grid[i].size(); j++) {
	float c = grid->grid[i][j].getObjectPresenceCounters();
	Eigen::Vector2f pos = grid->getPos(i,j);
	if (pos.x() < panMin || pos.x() > panMax || pos.y() < tiltMin || pos.y() > tiltMax) continue;
	//			cv::Point3f newColor = HSV_to_RGB(color);
				
	Eigen::Vector2f extent = getQuadExtent(pos, r);
				
	visualization_msgs::Marker m;
	m.header.frame_id = TARGET_FRAME;
	m.header.stamp = ros::Time::now();
	m.ns = "quad";
	m.action = visualization_msgs::Marker::ADD;
	m.type = visualization_msgs::Marker::CUBE;
	m.lifetime = ros::Duration(1.0f);
	m.id = id++;
				
	m.color.r = 1 - c/maxCount;
	m.color.g = c/maxCount;
	m.color.a = (grid->grid[i][j].getObjectPresenceCounters() == 0)? 0.0 : 0.8;
	//			m.color.a = 1.0;
				
	m.pose.position = angleToPTU(pos.x(), pos.y(), r);
	tf::Quaternion q = angleToQuat(pos.x(), pos.y());
	m.pose.orientation.x = q.x();
	m.pose.orientation.y = q.y();
	m.pose.orientation.z = q.z();
	m.pose.orientation.w = q.w();
				
	m.scale.x = extent.x() - GRID_SCALE;
	m.scale.y = extent.y() - GRID_SCALE;
	m.scale.z = GRID_SCALE;
				
	cubes.markers.push_back(m);
      }
    }
		
    maxID = (maxID < id)? id : maxID;
		
    if(!cubes.markers.empty()) qgPublisher.publish(cubes);
		
  }
	
  void RVizVisualization::drawSamples() {
    //	if (activeObjects.size() == 0) return;
		
    float r = TS_RADIUS * 0.995;
    float scale = GRID_SCALE * 2;
    //	int obj = activeObjects[0];
    visualization_msgs::Marker sampleList;
    sampleList.header.frame_id = TARGET_FRAME;
    sampleList.header.stamp = ros::Time::now();
    sampleList.ns = "samples";
    sampleList.action = visualization_msgs::Marker::ADD;
    sampleList.type = visualization_msgs::Marker::SPHERE_LIST;
    sampleList.lifetime = ros::Duration(1.0f);
    sampleList.id = ID_SAMPLES;
		
    sampleList.scale.x = scale;
    sampleList.scale.y = scale;
    sampleList.scale.z = scale;
    sampleList.color.r = 0;
    sampleList.color.g = 0;
    sampleList.color.b = 1;
    sampleList.color.a = 1.0;
		
    visualization_msgs::Marker sample3dList;
    sample3dList.header.frame_id = TARGET_FRAME;
    sample3dList.header.stamp = ros::Time::now();
    sample3dList.ns = "samples";
    sample3dList.action = visualization_msgs::Marker::ADD;
    sample3dList.type = visualization_msgs::Marker::SPHERE_LIST;
    sample3dList.lifetime = ros::Duration(1.0f);
    sample3dList.id = ID_SAMPLES_3D;
		
    sample3dList.scale.x = scale;
    sample3dList.scale.y = scale;
    sample3dList.scale.z = scale;
    sample3dList.color.r = 1;
    sample3dList.color.g = 0;
    sample3dList.color.b = 0;
    sample3dList.color.a = 1.0;
		
    for (std::vector<Quad> qVector : grid->grid) {
      for (Quad q : qVector) {
				
	for(auto& typeAndIDMultimapPair : q.samples2D) {
	  for(auto& idAndD2VectorPair : typeAndIDMultimapPair.second) {

	    for(auto& d2 : idAndD2VectorPair.second){
	      
	      geometry_msgs::Point p = angleToPTU(d2.x(), d2.y(), r);
	      sampleList.points.push_back(p);

	    }

	  }
	}
	for(auto& typeAndIDMultimapPair : q.samples3D) {
	  for(auto& idAndD3R3VectorPair : typeAndIDMultimapPair.second) {

	    for(auto& d3R3 : idAndD3R3VectorPair.second){
	      
	      geometry_msgs::Point p3d;
	      p3d.x = d3R3.first.x();
	      p3d.y = d3R3.first.y();
	      p3d.z = d3R3.first.z();
	      sample3dList.points.push_back(p3d);

	    }

	  }
	}
				
      }
    }
		
    if(!sampleList.points.empty()) samples2dPublisher.publish(sampleList);
    if(!sample3dList.points.empty()) samples3dPublisher.publish(sample3dList);
  }
	
  void RVizVisualization::drawUnfoundObjectsVotes() {

    if(!grid->mUnfoundObjects.size())
      return;
		
    auto colorSteps = 1.0 / (double) (grid->mUnfoundObjects.size());
    int id = 1;
		
    std::vector<double> colors;
    for (auto objectIterator = grid->mUnfoundObjects.begin(); objectIterator != grid->mUnfoundObjects.end(); objectIterator++)
      colors.push_back((std::distance(grid->mUnfoundObjects.begin(), objectIterator)+1) * colorSteps);
		
    for (std::vector<Quad> qVector : grid->grid) {
      for (Quad q : qVector) {
				
	for(auto& typeAndIDMultimapPair : q.samples3D) {
	  for(auto& idAndD3R3VectorPair : typeAndIDMultimapPair.second) {
						
	    for(auto& d3R3 : idAndD3R3VectorPair.second){

	      auto unfoundIterator = grid->mUnfoundObjects.find(std::make_pair(typeAndIDMultimapPair.first, idAndD3R3VectorPair.first));
						
	      ISM::PointPtr p3d(new ISM::Point(d3R3.first.x(), d3R3.first.y(), d3R3.first.z()));
	      ISM::PointPtr r3d(new ISM::Point(d3R3.second.x(), d3R3.second.y(), d3R3.second.z()));
						
          auto m = this->arrowBetweenPoints2(r3d, p3d);
	      m.id = id++;
	      std::stringstream nss;
	      nss << "arrows_" << typeAndIDMultimapPair.first << "_" << idAndD3R3VectorPair.first;
	      m.ns = nss.str();
	      m.lifetime = ros::Duration(1.0f);

	      m.color = this->confidenceToColor(colors[std::distance(grid->mUnfoundObjects.begin(), unfoundIterator)]);
	      arrowPublisher.publish(m);

	    }
						
	  }
	}
				
      }
			
    }
  }


    /*
  visualization_msgs::Marker RVizVisualization::arrowBetweenPoints(const ISM::PointPtr& point1, 
								   const ISM::PointPtr& point2, unsigned char action) {
    std::vector<Visualizer::CoordinateVectorPtr> points {point1, point2};
    return (Visualizer::arrowBetweenPoints(points, 0.024, 0.04, 0.04, TARGET_FRAME, 1.0f, action));
  }
    */
  //Redundant function just to set lifetime -> please change this... and an additional function parameter above.
  visualization_msgs::Marker RVizVisualization::arrowBetweenPoints2(const ISM::PointPtr& point1, const ISM::PointPtr& point2) {
    visualization_msgs::Marker m;
    m.header.stamp = ros::Time::now();
    m.header.frame_id = TARGET_FRAME;
    m.scale.x = 0.018;
    m.scale.y = 0.03;
    m.scale.z = 0.03;
    m.type = visualization_msgs::Marker::ARROW;
    m.action = visualization_msgs::Marker::ADD;
    m.points.push_back(pointToPointMsg(point1));
    m.points.push_back(pointToPointMsg(point2));
    m.lifetime = ros::Duration(1.0f);
    return m;
  }
	
  geometry_msgs::Point RVizVisualization::pointToPointMsg(ISM::PointPtr point) {
    return (Visualizer::pointToPointMsg(point));
  }

  std_msgs::ColorRGBA RVizVisualization::confidenceToColor(double confidence) {
    return (Visualizer::confidenceToColor(confidence, 0, 120, 5, 1));
  }

  void
  RVizVisualization::initAnimatedPlot(const std::string& pPlotTitle, const std::string& pXLabel, const std::string& pYLabel, const std::pair<float, float>& pXRange, const std::pair<float, float>& pYRange, const std::pair<float, float>& pDelta) {

    //Create a clean interface to gnuplot.
    mGnuplotHandler.reset(new Gnuplot);

    //Empty buffers with data for gnuplot.
    mUnfoundBuffer.clear();
    mFoundBuffer.clear();

    //Set bar chart title
    *(mGnuplotHandler) << "set title \"" << pPlotTitle << "\"\n";

    //Unit length in plot of both x and y axis are equal.
    *(mGnuplotHandler) << "set size ratio -1\n";

    //Style for points
    *(mGnuplotHandler) << "set border linewidth 0.5\n";
    *(mGnuplotHandler) << "set pointsize 1\n";
    *(mGnuplotHandler) << "set style line 1 lc rgb '#00008b' pt 5\n";
    *(mGnuplotHandler) << "set style line 2 lc rgb '#00ced1' pt 7\n";

    //Set labels for axes
    *(mGnuplotHandler) << "set xlabel \"" << pXLabel << "\"\n";
    *(mGnuplotHandler) << "set ylabel \"" << pYLabel << "\"\n";
	
    //Set range in both x and y direction
    *(mGnuplotHandler) << "set xrange [" << pXRange.second <<  ":" << pXRange.first << "]\n";
    *(mGnuplotHandler) << "set yrange [" << pYRange.first <<  ":" << pYRange.second << "]\n";

    //Ask for a grid for highres ticks
    *(mGnuplotHandler) << "set grid x2tics lc rgb \"#bbbbbb\"\n";
    *(mGnuplotHandler) << "set grid y2tics lc rgb \"#bbbbbb\"\n";

    //Lowres ticks
    *(mGnuplotHandler) << "set xtics " << pXRange.first << "," << pDelta.first * 4 << "," << pXRange.second <<"rotate\n";
    *(mGnuplotHandler) << "set ytics " << pYRange.first << "," << pDelta.second * 4 << "," << pYRange.second <<"\n";

    //Highres tics
    *(mGnuplotHandler) << "set x2tics " << pXRange.first << "," << pDelta.first << "," << pXRange.second <<" scale 0\n";
    *(mGnuplotHandler) << "set y2tics " << pYRange.first << "," << pDelta.second << "," << pYRange.second <<" scale 0\n";

    //Highres ticks with labels please
    *(mGnuplotHandler) << "set format y2 \"\"\n";
    *(mGnuplotHandler) << "set format x2 \"\"\n";

  }

void
RVizVisualization::updateFoundValues(ISM::ObjectSetPtr foundObjects) {

  mFoundBuffer.clear();

  for(auto& object : foundObjects->getObjects()) {

    ISM::PointPtr position = object->getPosePtr()->getPointPtr();
    
    Eigen::Vector3f p(position->getX(), position->getY(), position->getZ());

    Eigen::Vector2f sc = grid->toSphereCoords(p);
	
    mFoundBuffer.push_back(std::make_pair(sc.x(), sc.y()));

  }

}

void
RVizVisualization::updateUnfoundValues(std::vector<std::vector<Quad> > grid, const View& nextView, const View& currentView) {

  mUnfoundBuffer.clear();

  //Do not accept to alter visualization with non-existing gnuplot handler, even though this would not lead to null pointer exception.
  if(!mGnuplotHandler)
    throw std::runtime_error("Cannot update non-existing gnuplot visualization.");

    for (std::vector<Quad> qVector : grid) {
      for (Quad q : qVector) {
				
	for(auto& typeAndIDMultimapPair : q.samples2D) {

	  for(auto& idAndD2VectorPair : typeAndIDMultimapPair.second) {

	    for(auto& d2 : idAndD2VectorPair.second){

	    //mUnfoundBuffer[typeAndIDMultimapPair.first][idAndD2VectorPair.first].push_back(std::make_pair(d2.x(), d2.y()));
	    mUnfoundBuffer.push_back(std::make_pair(d2.x(), d2.y()));
	    
	    }

	  }
	}
      }
    }
    
    startNext.x() = nextView.center.x() - nextView.fov.x() * 0.5;
    startNext.y() = nextView.center.y() - nextView.fov.y() * 0.5;

    endNext.x() = nextView.center.x() + nextView.fov.x() * 0.5;
    endNext.y() = nextView.center.y() + nextView.fov.y() * 0.5;

    startCurrent.x() = currentView.center.x() - currentView.fov.x() * 0.5;
    startCurrent.y() = currentView.center.y() - currentView.fov.y() * 0.5;

    endCurrent.x() = currentView.center.x() + currentView.fov.x() * 0.5;
    endCurrent.y() = currentView.center.y() + currentView.fov.y() * 0.5;

}

  void
  RVizVisualization::sendPlotToGnuplot() {

    //Prevent system from trying to send data to non-initialized gnuplot handler
    if(!mGnuplotHandler)
      throw std::runtime_error("Cannot show non-existing gnuplot visualization.");

    *(mGnuplotHandler) << "set object 1 rect from " << startNext.x() << "," << startNext.y() << " to " << endNext.x() << "," << endNext.y() << " fs transparent solid 0.5 fc rgb \"green\"\n";
    *(mGnuplotHandler) << "set object 2 rect from " << startCurrent.x() << "," << startCurrent.y() << " to " << endCurrent.x() << "," << endCurrent.y() << " fs transparent solid 0.5 fc rgb \"red\"\n";

    //Every data combination has in common it wants to be plotted.
    *(mGnuplotHandler) << "plot ";
    
    //This should be later called in a loop with type and id as parameters
    *(mGnuplotHandler) << "'-' with points ls 1 title \"Found Objects\"";
    //This should be later called in a loop with type and id as parameters
    *(mGnuplotHandler) << ", '-' with points ls 2 title \"Object Hypotheses\"";

    //End of gnuplot instructions for defining how bars are to be plotted
    *(mGnuplotHandler) << "\n";

    //Later I should call .send(mUnfoundBuffer), on the gnuplothandler handler it returns, as often as the number of objects that I search for.

    //Push bar chart data to gnuplot.
    mGnuplotHandler->send(mFoundBuffer).send(mUnfoundBuffer);
    mGnuplotHandler->flush();

    if(enableEvaluation){

      //Tell gnuplot to talk postscript
      *(mGnuplotHandler) << "set terminal postscript\n";

      //Tell him where to write.
      *(mGnuplotHandler) << "set output '" << absPathDir.str() << "asr" << ros::Time::now().toNSec() <<  ".eps'\n";
      //Tell him to generate plot again
      *(mGnuplotHandler) << "replot\n";

      //Push bar chart data to gnuplot.
      mGnuplotHandler->send(mFoundBuffer).send(mUnfoundBuffer);
      mGnuplotHandler->flush();

      //Tell gnuplot to talk to window system again
      *(mGnuplotHandler) << "set terminal wxt\n";
    
      //And no file to write
      *(mGnuplotHandler) << "set output\n";

    }

  }
		
}
